# Dune slipface deposition rate measurement utility

# Copyright 2012-2014, Thomas E. Barchyn, Chris Hugenholtz
# Contact: Thomas E. Barchyn [tbarchyn@gmail.com]

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# Please familiarize yourself with the license of this tool, available
# in the distribution with the filename: license_deporate_tool.txt
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# PREAMBLE
# This program is intended to supplement a scientific publication
# detailing slipface deposition in sand dunes. Details about the algorithm,
# its use, and parameters are provided within the paper and/or
# supplementary information.

# Please note, as detailed above, this program is provided without a warranty and
# 'as is'. We have tried to make this program error free, but we cannot be responsible
# for any output from this program, or your use of any output from this program.

# OUTLINE:
# 1) arc_ascii class: a basic object to handle arc ascii rasters, reading, writing, etc.
# 2) functions: basic functions that are subsequently called in calculations
# 3) code to parse and check arguments, in one of three different user modes
# 4) main calculation code: implements the algorithms described in the manuscript
# 5) write code: write out the results to one of several data formats, based on run mode

# NOTES:
# 1) outputs to the console can be logged by setting the variable 'log' to True. This can
#    be adjusted in the portion of the code after function declarations. Console outputs
#    are logged to a local file called 'execlog.txt'.
# 2) python package dependencies: numpy

# OPERATION MODES:
# The program can run in one of 3 modes:
# 1) 'arc' = called from the ArcGIS toolbox included with the distribution (see 'readme file')
# 2) 'interactive' = interactive command line tool (arguments interactively grabbed from user)
# 3) 'batch' = command line arguments are passed to the script, first argument is 'batch'
#              the rest of the arguments are space separated (see 'readme file')



# ======================================================================================
# Classes: arc_ascii class
class arc_ascii:
    """Basic ArcGIS ASCII raster class: constructor requires filename argument"""
    # ==================================================================================================   
    # Constructor: reads a arc ascii file into memory
    # Argument: input file name (either local path, or absolute path)
    # Note: requires numpy, the raster is stored as a 2 dimensional numpy array
    def __init__(self, filename):
        # Note: there are no standards for the arc ascii file format, so it is critical to take
        # great care with this constructor. This works with arc ascii files generated by ArcGIS and
        # GlobalMapper. We suspect it will work fine with other arc ascii files, but cannot confirm
        # every GIS program out there will make files that can be read by this constructor. Let us
        # know if it doesn't work with yours, and we can work together on a fix.
        
        print ('Reading file: ' + filename)
        self.originfile = filename                  # record the origin file location       
        f = open (filename, mode = 'r')
        
        # Start the search through the header for the header data. Usually the header is the first 6 lines.
        count = 0           
        while count < 10:
            # Read the each header line into memory and ensure the endline character is removed
            line = f.readline()
            line = line.rstrip ('\n')
            line = line.rstrip ('\r')
            line = line.rstrip ('\cr')
            
            # Split the line with generic white space split: there is no consistency in whitespace in arc ascii headers
            linesplit  = line.split ()
            if len (linesplit) > 2:
                break      # break, we are reading the first part of the raster, header read completed
            
            # Try to parse into all the different attributes and assign internals
            # the projection and cellsizes are stored as character strings, often these are too long for
            # floating point representation and the output raster won't project properly if the numbers are rounded
            # Internally storing the projection values as character strings avoids this problem.
            if linesplit[0] == 'nrow' or linesplit[0] == 'NROW' or linesplit[0] == 'nrows' or linesplit[0] == 'NROWS':
                self.nrow = int (linesplit[1])
            if linesplit[0] == 'ncol' or linesplit[0] == 'NCOL' or linesplit[0] == 'ncols' or linesplit[0] == 'NCOLS':
                self.ncol = int (linesplit[1])
            if linesplit[0] == 'xllcorner' or linesplit[0] == 'XLLCORNER':
                self.xllcorner = linesplit[1]
            if linesplit[0] == 'yllcorner' or linesplit[0] == 'YLLCORNER':
                self.yllcorner = linesplit[1]
            if linesplit[0] == 'cellsize' or linesplit[0] == 'CELLSIZE':
                self.cellsize = linesplit[1]
            if linesplit[0] == 'NODATA_value' or linesplit[0] == 'NODATA_VALUE':
                self.nodata_val = float(linesplit[1])
            count = count + 1       # advance the row counter
        
        # Deal with missing values, these should be present in all rasters, but just in case
        # attempt to do a fake assignment of a local variable which fails if the variable doesn't exist
        # For some rasters without projection information, I've included defaults that results in a generic output.
        # Rasters without number of rows or number of columns fail though, this is likely a header read problem.
        try:
            x = self.nrow
        except:
            raise TypeError ('ERROR: require number of rows in header')
        try:
            x = self.ncol
        except:
            raise TypeError ('ERROR: require number of columns in header')
        try:
            x = self.xllcorner
        except:
            self.xllcorner = '0.0'
        try:
            x = self.yllcorner
        except:
            self.yllcorner = '0.0'
        try: 
            x = self.cellsize
        except:
            self.cellsize = '1.0'    
        try:
            x = self.nodata_val
        except:
            self.nodata_val = None
            
        # Rewind the file read pointer and try to find the beginning of the raster
        f.seek(0, 0)
        count = 0
        while count < 20:
            line = f.readline()
            linesplit = line.split ()
            if len (linesplit) == self.ncol:
                break       # Break, we just read the first line of the raster
            count = count + 1
            if count == 20:
                raise TypeError ('ERROR: File read could not find beginning of raster')
                
        # Back up and read up to that point again, setting the file read pointer so raster is next to read
        f.seek(0, 0)
        count2 = 0
        while count2 < count:
            line = f.readline()
            count2 = count2 + 1
        
        # Set up a raster object and fill it with empty cells
        self.ras = numpy.empty (shape = [self.nrow, self.ncol], dtype = 'float')
        for i in range(0, self.nrow):
            for j in range(0, self.ncol):
                self.ras[i, j] = numpy.NaN
                
        # Now, read in the file into the numpy array
        for i in range(0, self.nrow):
            # Read the line in and split it
            line = f.readline()
            linesplit = line.split()       # split with generic whitespace split
            # File read integrity check
            if len(linesplit) != self.ncol:
                raise TypeError ('ERROR: Raster read error, number of columns does not match header')
                
            # assign the elements to the array
            for j in range(0, self.ncol):
                if float(linesplit[j]) == self.nodata_val:
                    self.ras[i, j] = numpy.NaN      # assign nan value
                else:
                    self.ras[i, j] = float (linesplit[j])
        f.close()
        print ('File successfully read into memory . . .')
    
    # ==================================================================================================   
    # Method for describing the raster object
    def desc(self):
        print ('ARC GIS ASCII Text raster')
        print ('File originated from: ' + self.originfile)
        print ('Number of rows: ' + str(self.nrow))
        print ('Number of cols: ' + str(self.ncol))
        print ('XLL corner: ' + self.xllcorner)
        print ('YLL corner: ' + self.yllcorner)
        print ('Cellsize: ' + self.cellsize)
        print ('No data value: ' + str(self.nodata_val))
    
    # ==================================================================================================       
    # Method for writing the raster file
    def write(self, outfile):
        # Argument: outfile file location
        print ('Writing file: ' + outfile)
        f = open (outfile, mode = 'w')
        
        # Write the header lines
        f.write ('ncols ' + str(self.ncol) + '\n')
        f.write ('nrows ' + str(self.nrow) + '\n')
        f.write ('xllcorner ' + self.xllcorner + '\n')
        f.write ('yllcorner ' + self.yllcorner + '\n')
        f.write ('cellsize ' + self.cellsize + '\n')
        if not self.nodata_val == None:
            f.write ('nodata_value ' + str(self.nodata_val) + '\n')
        
        # Write the raster contents
        for i in range (0, self.nrow):
            for j in range (0, (self.ncol - 1)):
                if numpy.isnan (self.ras[i, j]):
                    f.write (str(self.nodata_val) + ' ')
                else:
                    f.write (str(self.ras[i, j]) + ' ')
            # Write the last value of the row with an endline character, which is set as '\n'
            if numpy.isnan (self.ras[i, (self.ncol - 1)]):
                f.write (str(self.nodata_val) + '\n')
            else:            
                f.write (str(self.ras[i, (self.ncol - 1)]) + '\n')
        
        f.close()
        print ('File successfully written . . .')
        
# ======================================================================================
# Functions: these are subsequently called below
def statusprint(message):
    # Mode independent method of printing messages to the console
    if mode == 'arc':
        arcpy.AddMessage(message)
    else:
        print(message)
    
    # Log messages to a local log file if 'log' is true (set in start of the program below)
    if log:
        f = open ('execlog.txt', 'a')       # append to whatever is there already
        f.write (message + '\n')
        f.close()
               
def quitprogram():
    # Generic method of quitting the program after a message has been displayed
    if mode == 'arc' or mode == 'batch':
        sys.exit()
    else:
        statusprint("Exiting program in 3 seconds")
        time.sleep(3)           # sleep for 3 seconds to allow user to read any error message
        sys.exit()

def welcome():
    # Print the welcome messages to the console or Arcgis script status window
    statusprint ("======================================")
    statusprint ("Welcome to the slipface deposition rate measurement utility.")
    statusprint ("Copyright 2012-2014, Thomas E. Barchyn, Chris H. Hugenholtz.")
    statusprint ("Contact: Thomas E. Barchyn [tbarchyn@gmail.com]\n")
    
    statusprint ("This program is free software: you can redistribute it and/or modify")
    statusprint ("it under the terms of the GNU General Public License as published by")
    statusprint ("the Free Software Foundation, either version 3 of the License, or")
    statusprint ("(at your option) any later version.\n")

    statusprint ("This program is distributed in the hope that it will be useful,")
    statusprint ("but WITHOUT ANY WARRANTY; without even the implied warranty of")
    statusprint ("MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the")
    statusprint ("GNU General Public License for more details.\n")

    statusprint ("Please familiarize yourself with the license for this tool, available")
    statusprint ("with this distribution in the file: license_deporate_tool.txt")
    statusprint ("You should have received a copy of the GNU General Public License")
    statusprint ("along with this program.  If not, see <http://www.gnu.org/licenses/>.\n")

    statusprint ("Presently running script in '" + mode + "' mode")
    statusprint ("Time: " + str(datetime.datetime.now())[:-7])
    statusprint ("======================================")
    return

def slope_aspect(inraster, cellsize):
    # Method to calculate slope and aspect with the Horn (1981) method, identical to ArcGIS
    # The algorithm is also detailed in ArcGIS help at the sites:
    # http://help.arcgis.com/en/arcgisdesktop/10.0/help/index.html#/How_Slope_works/009z000000vz000000/
    # http://help.arcgis.com/en/arcgisdesktop/10.0/help/index.html#/How_Aspect_works/009z000000vp000000/ 
    # Arguments:
    # inraster = NUMPY array raster of topography that is used to calculate slope
    # cellsize = size of cells in real units, if it is unknown, include a value of 1.0
    # Note: this function returns NaN when one of the cells in the 3 by 3 neighborhood
    #       are missing, this is different than ArcGIS, which produces values for these points
    # Note: this function returns NaN when the slope is zero (e.g., flat), this is deliberate
    #       to avoid any subsequent problems. A flat slope has no aspect and cannot be used
    #       in our algorithm.
    
    nrow = inraster.shape[0]        # get some local copies of the array dimensions
    ncol = inraster.shape[1]
    
    # Create floating point output rasters that is equivalent size to input
    out_slp = numpy.zeros (shape = (nrow, ncol), dtype = 'float')
    out_asp = numpy.zeros (shape = (nrow, ncol), dtype = 'float')
    
    # Set every cell to NaN in the raster
    for i in range (0, nrow):
        for j in range (0, ncol):
            out_slp[i, j] = numpy.NaN
            out_asp[i, j] = numpy.NaN
    
    # Loop over raster and calculate slope, don't calculate edge cells
    for i in range (1, (nrow-1)):
        for j in range (1, (ncol-1)):
            # First check to see if all 9 cells in the neighborhood are present
            if not numpy.isnan(inraster[i-1, j-1]) and not numpy.isnan(inraster[i-1, j]) and not numpy.isnan(inraster[i-1, j+1]):
                if not numpy.isnan(inraster[i, j-1]) and not numpy.isnan(inraster[i, j]) and not numpy.isnan(inraster[i, j+1]):
                    if not numpy.isnan(inraster[i+1, j-1]) and not numpy.isnan(inraster[i+1, j]) and not numpy.isnan(inraster[i+1, j+1]):
                        
                        # If we passed these condition checks, all 9 cells should be present
                        # Calculate dz_dx and dz_dy
                        dz_dx = (inraster[i-1, j+1] + (2.0 * inraster[i, j+1]) + inraster[i+1, j+1] - inraster[i-1, j-1] - (2.0 * inraster[i, j-1]) - inraster[i+1, j-1]) / (8.0 * cellsize)
                        dz_dy = (inraster[i+1, j-1] + (2.0 * inraster[i+1, j]) + inraster[i+1, j+1] - inraster[i-1, j-1] - (2.0 * inraster[i-1, j]) - inraster[i-1, j+1]) / (8.0 * cellsize)
                        
                        # Calculate slope by first calculating the rise / run
                        rise_run = math.sqrt (math.pow(dz_dx, 2.0) + math.pow(dz_dy, 2.0))
                        
                        # Calculate the slope in degrees and assign it to the raster, if it is not zero
                        if rise_run != 0.0:
                            slope = math.atan (rise_run) * (180.0 / math.pi)
                            out_slp[i, j] = slope
                        else:
                            out_slp[i, j] = numpy.NaN   # return missing data point if slope is zero
                        
                        # Calculate aspect
                        if dz_dx == 0.0 and dz_dy == 0.0:
                            out_asp[i, j] = numpy.NaN       # return missing data point if the site is flat
                        
                        else:
                            # if the site has a slope calculate the aspect in degrees
                            aspect = math.atan2 (dz_dy, (-1.0 * dz_dx)) * (180.0 / math.pi)
                        
                            # Now, convert this value to a compass azimuth
                            if aspect < 0.0:
                                aspect = 90.0 - aspect
                            elif aspect > 90.0:
                                aspect = 360.0 - aspect + 90.0
                            else:
                                aspect = 90.0 - aspect
                                
                            # assign the value to the output raster
                            out_asp[i, j] = aspect
    
    # Return the output rasters
    return out_slp, out_asp

def write_raster(outraster, name):
    # A generic method to write raster objects out
    # Arguments:
    # 1) outraster: the numpy array to write out
    # 2) name: the file name to write out, without file extension. This is because
    #    if the program is running in 'batch' or 'interactive' mode, the function adds '.asc' extension.
    if mode == 'arc':
        # Write out an ESRI grid file
        oput_name = os.path.join (oput_directory, name)
        # Use the same spatial parameters as the input topography file
        out_raster = arcpy.NumPyArrayToRaster (outraster, pnt, cellsize, cellsize)
        out_raster.save (oput_name)                         # save the 'raster' object
        arcpy.CalculateStatistics_management (oput_name)    # calculate statistics for quicker viewing
        # Try to define the projection, which makes reading in ArcGIS quite a bit easier
        try:
            arcpy.DefineProjection_management (oput_name, spatialReference)
        except:
            pass
          
    else:
        # Else, output an arc ascii file as the program is in 'batch' or 'interactive' mode
        oput_name = os.path.join (oput_directory, name + '.asc')
        oput_obj = copy.deepcopy (topo_obj)     # deepcopy the input topography arc_ascii object
        oput_obj.ras = outraster                # copy in the output raster numpy array
        oput_obj.write (oput_name)              # write the file to disk
    
    return

def interp_aspect(i_in, j_in, mult):
    # Method for interpolating the aspect from 4 nearest neighbours with weighted distance algorithm
    # Arguments:
    # 1) focal cell coordinates (row, column)
    # 2) a multiplier, which is will be either 0.5 * trap_width or -0.5 * trap_width (to define which way along strike)
    #    Note that this multiplier is in real distances, so we have to first adjust the multiplier to be measured
    #    in raster cell widths. The spatial unit of raster cell widths is used in all calculations in this function.
    # Note: this function will only interpolate from slipface cells. This means cells that were pre-tagged in the
    #    masking portion of the code as having non-missing data points and suitable slopes are only used in aspect
    #    interpolation. This has a great bearing on the number of cells that make it through this portion of the
    #    analysis, because it means that only 'slipface cells' are used to calculate adjacent aspects.
    
    mult = mult / cellsize      # convert the multiplier to raster coordinate units
            
    # We must define the point to interpolate the values for. This point will be directly along the
    # 'strike' of a given aspect measurement ('strike' meaning the perpendicular to aspect measurement
    # per use in strata orientation in geology).
        
    # Calculate the shifts in the i and j directions for the interpolation point
    i_shift = mult * math.sin (asp[i_in, j_in] * math.pi / 180.0)
    j_shift = mult * math.cos (asp[i_in, j_in] * math.pi / 180.0)
    
    # Calculate the precise location in the raster with the shifts
    i_fl = float (i_in + i_shift)      # note: these are floating point representations of the position
    j_fl = float (j_in + j_shift)
    
    # Determine the four adjacent cells, named with compass directions
    i_n = int (math.floor (i_fl))
    i_s = int (math.ceil (i_fl))
    j_w = int (math.floor (j_fl))
    j_e = int (math.ceil (j_fl))
    
    # Try to calculate distances
    try:
        # Now, perform a check to ensure that the raster cells are tagged as slipface cells
        # Note this will also ensure adjacent cells have non-missing aspect values (checked in mask)
        if mask[i_n, j_w] and mask[i_n, j_e] and mask[i_s, j_w] and mask[i_s, j_e]:
            # If the cells passed the above checks, we are OK to interpolate the aspect value
            # To interpolate the aspect, we first need to convert the adjacent aspects to x
            # and y components and average the components.
            x_nw = math.sin (asp [i_n, j_w] * math.pi / 180.0)
            x_ne = math.sin (asp [i_n, j_e] * math.pi / 180.0)
            x_sw = math.sin (asp [i_s, j_w] * math.pi / 180.0)
            x_se = math.sin (asp [i_s, j_e] * math.pi / 180.0)
            
            y_nw = math.cos (asp [i_n, j_w] * math.pi / 180.0)
            y_ne = math.cos (asp [i_n, j_e] * math.pi / 180.0)
            y_sw = math.cos (asp [i_s, j_w] * math.pi / 180.0)
            y_se = math.cos (asp [i_s, j_e] * math.pi / 180.0)
            
            # Determine the distances to each adjacent cell, named with compass directions
            dist_nw = math.sqrt (math.pow ((i_fl - i_n), 2.0) + math.pow ((j_fl - j_w), 2.0))
            dist_ne = math.sqrt (math.pow ((i_fl - i_n), 2.0) + math.pow ((j_fl - j_e), 2.0))
            dist_sw = math.sqrt (math.pow ((i_fl - i_s), 2.0) + math.pow ((j_fl - j_w), 2.0))
            dist_se = math.sqrt (math.pow ((i_fl - i_s), 2.0) + math.pow ((j_fl - j_e), 2.0))
             
            # Calculating the weights for each adjacent cell
            weighting_pow = 1.0         # set the weighting power, using 1.0 for now
            weight_nw = 1.0 / math.pow (dist_nw, weighting_pow)
            weight_ne = 1.0 / math.pow (dist_ne, weighting_pow)
            weight_sw = 1.0 / math.pow (dist_sw, weighting_pow)
            weight_se = 1.0 / math.pow (dist_se, weighting_pow)
            
            # And perform the weighted average for each of the components
            x_mean = (weight_nw * x_nw) + (weight_ne * x_ne) + (weight_sw * x_sw) + (weight_se * x_se)
            x_mean = x_mean / (weight_nw + weight_ne + weight_sw + weight_se)
            
            y_mean = (weight_nw * y_nw) + (weight_ne * y_ne) + (weight_sw * y_sw) + (weight_se * y_se)
            y_mean = y_mean / (weight_nw + weight_ne + weight_sw + weight_se)
            
            # Modify the components back to a compass azimuth in degrees
            if x_mean >= 0.0 and y_mean >= 0.0:
                mean_asp = math.atan (x_mean / y_mean) * 180.0 / math.pi
            elif x_mean >= 0.0 and y_mean <= 0.0:
                mean_asp = 90.0 + (-1.0 * math.atan (y_mean / x_mean) * 180.0 / math.pi)
            elif x_mean <= 0.0 and y_mean <= 0.0:
                mean_asp = 180.0 + (math.atan (x_mean / y_mean) * 180.0 / math.pi)
            else:
                mean_asp = 270.0 + (-1.0 * math.atan (y_mean / x_mean) * 180.0 / math.pi)

            # Return the result
            return mean_asp
            
            
        # Else, if any of the above fails or if statements aren't true, return a NaN
        else:
            return numpy.NaN
    except:
        return numpy.NaN

def walkuphill(i_in, j_in):
    # Walk uphill up the slipface and return the maximum value from the walk
    # Arguments:
    # i_in and j_in are focal cell coordinates
    # First grab the walking azimuth
    walk_az = asp[i_in, j_in] - 180.0
    if walk_az < 0.0:
        walk_az = 360.0 + walk_az
    
    # Set the i_shift and j_shift based on the direction of the azimuth
    if walk_az > 315.0 or walk_az <= 45.0:
        i_shift = -1        # set an integer shift value
        j_shift = math.tan (walk_az * math.pi / 180.0)
        walkdir = 'ns'
    elif walk_az > 45.0 and walk_az <= 135.0:
        i_shift = math.tan ((90.0 + walk_az) * math.pi / 180.0)
        j_shift = 1
        walkdir = 'ew'
    elif walk_az > 135.0 and walk_az <= 225.0:
        i_shift = 1
        j_shift = -1.0 * math.tan (walk_az * math.pi / 180.0)
        walkdir = 'ns'
    elif walk_az > 225.0 and walk_az <= 315.0:
        i_shift = -1.0 * math.tan ((90.0 + walk_az) * math.pi / 180.0)
        j_shift = -1
        walkdir = 'ew'
    else:
        statusprint("ERROR WITH AZIMUTH")
        quitprogram()
    
    # Set maxval to update
    maxval = topo[i_in, j_in]
    walk_interval = math.sqrt (math.pow ((i_shift * cellsize), 2.0) + math.pow ((j_shift * cellsize), 2.0))
    walk_counter = 0.0      # start the walk counter at 0.0 meters
    
    # if walk direction is north south
    if walkdir == 'ns':
        j_fl = float (j_in)     # Create floating point version of the coordinate
        while walk_counter < max_walk:
            
            # Set new coordinates
            i_in = i_in + i_shift
            j_fl = j_fl + j_shift
            
            # Determine the two j coordinates to test
            j_w = math.floor (j_fl)
            j_e = math.ceil (j_fl)
            
            # Ensure none of the coordinates are values that are NaN, or out of bounds,
            # if any of these coordinates are invalid, just return an NaN, and the calculation will fail
            if i_in >= 0 and i_in < nrows and j_w >= 0 and j_w < ncols and j_e >= 0 and j_e < ncols:
                if not numpy.isnan (topo[i_in, j_w]) and not numpy.isnan (topo[i_in, j_e]):
                    
                    # Calculate a linear interpolated average of the topographic value
                    if float (j_fl - j_w) != 0.0:
                        weight_w = 1.0 / float (j_fl - j_w)
                    else:
                        weight_w = 1.0
                        weight_e = 0.0
                    
                    if float (j_e - j_fl) != 0.0:
                        weight_e = 1.0 / float (j_e - j_fl)
                    else:
                        weight_w = 0.0
                        weight_e = 1.0
                    
                    # Calculate weighted average
                    topo_avg = ((weight_w * topo[i_in, j_w]) + (weight_e * topo[i_in, j_e])) / (weight_w + weight_e)
                    
                    # Update the maximum value
                    if topo_avg > maxval:
                        maxval = topo_avg
                    else:
                        break       # if we didn't update the maximum value, break from the walk, the
                                    # walk has gone past the edge of the slipface
                    walk_counter = walk_counter + walk_interval
                
                else:
                    return numpy.NaN    # return from the function with NaN
            else:
                return numpy.NaN    # return from the function with NaN           
    else:
        # Else, the walk direction must be east-west, start walking to the east or west
        i_fl = float (i_in)     # create floating point version of the coordinate
        while walk_counter < max_walk:
            
            # Set new coordinates
            i_fl = i_fl + i_shift
            j_in = j_in + j_shift
            
            # Determine the two i coordinates to test
            i_n = math.floor (i_fl)
            i_s = math.ceil (i_fl)
            
            # Ensure none of the coordinates are values that are NA, or out of bounds
            # If any of these coordinates are invalid, just return an NA, and the calculation will fail
            if i_n >= 0 and i_n < nrows and i_s >= 0 and i_s < nrows and j_in >= 0 and j_in < ncols:
                if not numpy.isnan (topo[i_n, j_in]) and not numpy.isnan (topo[i_s, j_in]):
                    
                    # Calculate a linear interpolated average of the topographic value
                    if float (i_fl - i_n) != 0.0:
                        weight_n = 1.0 / float (i_fl - i_n)
                    else:
                        weight_n = 1.0
                        weight_s = 0.0
                    
                    if float (i_s - i_fl) != 0.0:
                        weight_s = 1.0 / float (i_s - i_fl)
                    else:
                        weight_n = 0.0
                        weight_s = 1.0
                    
                    # Calculate weighted average
                    topo_avg = ((weight_n * topo[i_n, j_in]) + (weight_s * topo[i_s, j_in])) / (weight_n + weight_s)
                    
                    # Update the maximum value
                    if topo_avg > maxval:
                        maxval = topo_avg
                    else:
                        break       # if we didn't update the maximum value, break from the walk, the
                                    # walk has gone past the edge of the slipface
                    walk_counter = walk_counter + walk_interval
                
                else:
                    return numpy.NaN    # return from the function
            else:
                return numpy.NaN    # return from the function    
    return maxval
                    
def walkdownhill(i_in, j_in):
    # Walk downhill down the slipface and find the bottom of the slipface
    # Arguments:
    # i_in and j_in are focal cell coordinates
    # First grab the walking azimuth
    walk_az = asp[i_in, j_in]
    
    # Set the i_shift and j_shift based on the direction of the azimuth
    if walk_az > 315.0 or walk_az <= 45.0:
        i_shift = -1        # set an integer shift value
        j_shift = math.tan (walk_az * math.pi / 180.0)
        walkdir = 'ns'
    elif walk_az > 45.0 and walk_az <= 135.0:
        i_shift = math.tan ((90.0 + walk_az) * math.pi / 180.0)
        j_shift = 1
        walkdir = 'ew'
    elif walk_az > 135.0 and walk_az <= 225.0:
        i_shift = 1
        j_shift = -1.0 * math.tan (walk_az * math.pi / 180.0)
        walkdir = 'ns'
    elif walk_az > 225.0 and walk_az <= 315.0:
        i_shift = -1.0 * math.tan ((90.0 + walk_az) * math.pi / 180.0)
        j_shift = -1
        walkdir = 'ew'
    else:
        statusprint("ERROR WITH AZIMUTH")
        quitprogram()
    
    # Set minval to update
    minval = topo[i_in, j_in]
    walk_interval = math.sqrt (math.pow ((i_shift * cellsize), 2.0) + math.pow ((j_shift * cellsize), 2.0))
    walk_counter = 0.0
    
    # If walk direction is north south, start walking to the north or south
    if walkdir == 'ns':
        j_fl = float (j_in)     # create floating point version of the coordinate
        while walk_counter < max_walk:
            
            # Set new coordinates
            i_in = i_in + i_shift
            j_fl = j_fl + j_shift
            
            # Determine the two j coordinates to test
            j_w = math.floor (j_fl)
            j_e = math.ceil (j_fl)
            
            # Ensure none of the coordinates are values that are NA, or out of bounds
            # If any of these coordinates are invalid, just return an NA, and the calc will fail
            if i_in >= 0 and i_in < nrows and j_w >= 0 and j_w < ncols and j_e >= 0 and j_e < ncols:
                if not numpy.isnan (topo[i_in, j_w]) and not numpy.isnan (topo[i_in, j_e]):
                    
                    # Calculate a linear interpolated average of the topographic value
                    if float (j_fl - j_w) != 0.0:
                        weight_w = 1.0 / float (j_fl - j_w)
                    else:
                        weight_w = 1.0
                        weight_e = 0.0
                    
                    if float (j_e - j_fl) != 0.0:
                        weight_e = 1.0 / float (j_e - j_fl)
                    else:
                        weight_w = 0.0
                        weight_e = 1.0
                    
                    # Calculate weighted average
                    topo_avg = ((weight_w * topo[i_in, j_w]) + (weight_e * topo[i_in, j_e])) / (weight_w + weight_e)
                    
                    # Update the minimum value
                    if topo_avg < minval:
                        minval = topo_avg
                    else:
                        break       # if we didn't update the maximum value, break from the walk, the
                                    # walk has gone past the edge of the slipface
                    walk_counter = walk_counter + walk_interval
                
                else:
                    return numpy.NaN    # return from the function
            else:
                return numpy.NaN    # return from the function
            
    else:
        # Else, the walk direction must be east-west, start walking to the east or west
        i_fl = float (i_in)     # create floating point version of the coordinate
        while walk_counter < max_walk:
            
            # Set new coordinates
            i_fl = i_fl + i_shift
            j_in = j_in + j_shift
            
            # Determine the two i coordinates to test
            i_n = math.floor (i_fl)
            i_s = math.ceil (i_fl)
            
            # Ensure none of the coordinates are values that are NA, or out of bounds
            # If any of these coordinates are invalid, just return an NA, and the calc will fail
            if i_n >= 0 and i_n < nrows and i_s >= 0 and i_s < nrows and j_in >= 0 and j_in < ncols:
                if not numpy.isnan (topo[i_n, j_in]) and not numpy.isnan (topo[i_s, j_in]):
                    
                    # Calculate a linear interpolated average of the topographic value
                    if float (i_fl - i_n) != 0.0:
                        weight_n = 1.0 / float (i_fl - i_n)
                    else:
                        weight_n = 1.0
                        weight_s = 0.0
                    
                    if float (i_s - i_fl) != 0.0:
                        weight_s = 1.0 / float (i_s - i_fl)
                    else:
                        weight_n = 0.0
                        weight_s = 1.0
                    
                    # Calculate weighted average
                    topo_avg = ((weight_n * topo[i_n, j_in]) + (weight_s * topo[i_s, j_in])) / (weight_n + weight_s)
                    
                    # Update the minimum value
                    if topo_avg < minval:
                        minval = topo_avg
                    else:
                        break       # if we didn't update the maximum value, break from the walk, the
                                    # walk has gone past the edge of the slipface
                    walk_counter = walk_counter + walk_interval
                
                else:
                    return numpy.NaN    # return from the function
            else:
                return numpy.NaN    # return from the function    
    return minval


# ======================================================================================
# MAIN: START SCRIPT HERE >>>>>>
# Load the modules and prepare the Python interpreter
print("LOADING PYTHON MODULES >>>>")
try:
    import os
    import math
    import sys
    import time
    import copy
    import datetime
    print ("Python interpreter version: " + sys.version[0:6])
    global mode             # global flag variable to record which mode the program is running in
    log = True              # Set true to log console outputs to a local log file named: 'execlog.txt'
    
    try:
        import numpy                        # try to load the numpy module     
    except:
        print("ERROR: This program requires an additional add-on to Python called NUMPY")
        print("       please download and install from: www.numpy.scipy.org")
        time.sleep(3)
        sys.exit()
except:
    print("FAILED TO LOAD MODULES >>>>")
    time.sleep(3)
    sys.exit()


# Determine analysis mode by trying to grab arguments passed from ArcGIS
# The program can run in one of 3 modes (see 'readme' file for details):
# 1) 'arc' = called from the ArcGIS toolbox
# 2) 'interactive' = interactive command line tool
# 3) 'batch' = command line arguments are passed to the script, first argument is 'batch'
#              the rest of the arguments are space separated

# Start by trying to ingest command line arguments and determine if 'batch' is first argument
try:
    if sys.argv[1] == 'batch':
        mode = 'batch'              # set the mode flag
        diagnostics = True          # automatically output diagnostics output (all diagnostic rasters)
        if len(sys.argv) == 11:
            # Read the arguments
            topo_name = sys.argv[2]
            minslope = sys.argv[3]
            maxslope = sys.argv[4]
            repose = sys.argv[5]
            wind_az = sys.argv[6]
            flux = sys.argv[7]
            trap_width = sys.argv[8]
            max_walk = sys.argv[9]
            
            # Note: the output directory can be missing, just use present directory instead
            try:
                oput_directory = sys.argv[10]
            except:
                oput_directory = os.getcwd()
            
            welcome()       # Print welcome message
             
        else:
            statusprint("ERROR: batch mode arguments are not formatted properly")
            quitprogram()
    else:
        raise     # raise an error so the try expression fails and we can try other modes

except:
    # If the above fails, the program is running in 'arc' or 'interactive' mode
    try:
        # Now, try to populate the variables as if we are running in ArcGIS mode
        mode = 'arc'
    
        import arcpy                        # import the arcpy site package
        arcpy.env.overwriteOutput = True    # allow overwrites of output files
        
        # Grab the arguments as passed from ArcGIS tool
        topo_name = arcpy.GetParameterAsText(0)
        minslope = arcpy.GetParameterAsText(1)
        maxslope = arcpy.GetParameterAsText(2)
        repose = arcpy.GetParameterAsText(3)
        wind_az = arcpy.GetParameterAsText(4)
        flux = arcpy.GetParameterAsText(5)
        trap_width = arcpy.GetParameterAsText(6)
        max_walk = arcpy.GetParameterAsText(7)
        oput_directory = arcpy.GetParameterAsText(8)
        diagnostics = arcpy.GetParameterAsText(9)
       
        # Change the file names from layer names to full catalog paths
        topo_name_desc = arcpy.Describe(topo_name)
        topo_name = topo_name_desc.catalogPath
        
        # In arcmode users can decide whether or not to output diagnostic rasters
        if diagnostics == 'true':
            diagnostics = True
        else:
            diagnostics = False
        
        welcome()       # print welcome message
    
        
    except:
        # If any of the above fails, the program is running without ArcGIS and not in batch mode
        # We need to get the necessary parameters manually from the user via interactive commands
        mode = 'interactive'
        diagnostics = True          # automatically output diagnostics output
        
        # Set the default values for the variables             
        topo_name = 'MISSING'
        minslope = '20.0'
        maxslope = '90.0'
        repose = '34.0'
        wind_az = 'MISSING'
        flux = '1.0'
        trap_width = '8.0'
        max_walk = '40.0'
        oput_directory = os.getcwd()        # use current directory as starting directory
    
        welcome()       # print welcome message
        
        # Print and populate options in a while loop that ends (with 'break' command) when the user executes or quits the program
        while 1 == 1:
            statusprint ('======================================\nSet input data:')
            statusprint ('  1) topography file (arc ascii format): ' + topo_name)
            statusprint ('  2) minimum slope (degrees): ' + minslope)
            statusprint ('  3) maximum slope (degrees): ' + maxslope)
            statusprint ('  4) real angle of repose (degrees): ' + repose)
            statusprint ('  5) formative wind direction (azimuth): ' + wind_az)
            statusprint ('  6) yearly flux (m^2 / a): ' + flux)
            statusprint ('  7) slipface trapezoid width (m): ' + trap_width)
            statusprint ('  8) maximum walk distance (up or downhill) (m): ' + max_walk)
            statusprint ('  9) output directory: ' + oput_directory)
            statusprint ('  X) Execute program!')
            statusprint ('  Q) Quit')
            
            res = raw_input ('ENTER YOUR CHOICE:\n')        # get the choice from the user
            if res == '1':
                val = raw_input ('Enter name of file:\n')
                topo_name = val
            elif res == '2':
                val = raw_input ('Enter new value:\n')
                minslope = val
            elif res == '3':
                val = raw_input ('Enter new value:\n')
                maxslope = val
            elif res == '4':
                val = raw_input ('Enter new value:\n')
                repose = val
            elif res == '5':
                val = raw_input ('Enter new value:\n')
                wind_az = val
            elif res == '6':
                val = raw_input ('Enter new value:\n')
                flux = val
            elif res == '7':
                val = raw_input ('Enter new value:\n')
                trap_width = val
            elif res == '8':
                val = raw_input ('Enter new value:\n')
                max_walk = val
            elif res == '9':
                val = raw_input ('Enter new directory:\n')
                oput_directory = val
            elif res == 'X' or res == 'x':
                break                   # break and execute the rest of the script 
            elif res == 'Q' or res == 'q':
                quitprogram()           # quit from the script
            else:
                statusprint ('ERROR: could not interpret your command? Please try again')

# ======================================================================================
# Perform some input checks on the data and convert text strings to numbers where appropriate
# Perform some initial quality checks on the input measurements
try:
    minslope = float (minslope)
    if minslope > 90.0 or minslope < 0.0:
        statusprint("ERROR: minimum slope is not valid!")
        quitprogram()
    
    maxslope = float(maxslope)
    if maxslope > 90.0 or maxslope < 0.0:
        statusprint("ERROR: maximum slope is not valid!")
        quitprogram()
    
    repose = float(repose)
    if repose > 90.0 or repose < 0.0:
        statusprint("ERROR: angle of repose is not valid!")
        quitprogram()
    
    wind_az = float(wind_az)
    if wind_az > 360.0 or wind_az < 0.0:
        statusprint("ERROR: wind direction azimuth is not valid!")
        quitprogram()
        
    flux = float(flux)
    if flux <= 0.0:
        statusprint("ERROR: flux is not valid!")
        quitprogram()
        
    trap_width = float(trap_width)
    if trap_width <= 0.0:
        statusprint("ERROR: trapezoid width is not valid!")
        quitprogram()
    
    max_walk = float(max_walk)
    if max_walk <= 0.0:
        statusprint("ERROR: max walk is not valid!")
        quitprogram()
        
except:
    statusprint("ERROR: unable to parse input parameters")
    quitprogram()

# ======================================================================================
# Read in the topography file into memory
statusprint("READING INPUT FILE >>>>")

if mode == 'arc':
    # ArcGIS mode takes ESRI GRID files as input raster
    try:
        topo = arcpy.RasterToNumPyArray (topo_name)
        statusprint("Topography read in successfully")
        
    except:
        statusprint("Error reading topography!")
        quitprogram()
            
else:
    # Interactive mode takes Arc ASCII raster files as input
    try:
        topo_obj = arc_ascii (topo_name)
        topo = topo_obj.ras
    except:
        statusprint("Error reading topography!")
        quitprogram()

# ======================================================================================
# Begin preparation of variables for main calculations
statusprint ("======================================")
statusprint ("PREPARING ANALYSIS ENVIRONMENT >>>>")

if mode == 'arc':
    # Grab the spatial description data from the raw topography file using arcpy methods
    cellsize = topo_name_desc.meanCellHeight
    extent = topo_name_desc.Extent
    spatialReference = topo_name_desc.spatialReference
    pnt = arcpy.Point(extent.XMin, extent.YMin)

    # Double check that the projection is 'projected', meaning equal cellsize north-south and east-west
    if topo_name_desc.meanCellHeight != topo_name_desc.meanCellWidth:
        statusprint ("ERROR: input raster dataset must be in a 'projected' coordinate system (e.g., UTM)")
        statusprint ("Cells must be squares, meaning cellsize north-south must be equal to cellsize east-west")
        quitprogram ()

else:
    # Else, if running in 'interactive' or 'batch' mode, grab the cellsize from the arc_ascii object
    cellsize = float (topo_obj.cellsize)        # coerce into floating point number, stored internally as chars

# Determine the number of rows and columns as variables for use in the program
nrows = topo.shape[0]
ncols = topo.shape[1]
            
# Create a NUMPY boolean array to serve as a mask for the slipface cells
# The purpose of pre-masking out the cells to calculate slipface angle is to improve execution speed
mask = numpy.zeros (topo.shape, dtype = 'Bool')          # start with a NUMPY boolean array

# Ensure everything is set to False in the mask before starting
for i in range(0, nrows):
    for j in range(0, ncols):
        mask[i, j] = False

# Create blank arrays for output values by copying topographic array
oput_dhdt = copy.deepcopy(topo)
oput_wd = copy.deepcopy(topo)
oput_phi = copy.deepcopy(topo)
oput_gamma = copy.deepcopy(topo)
oput_b_up = copy.deepcopy(topo)
oput_b_down = copy.deepcopy(topo)

# Set the new output arrays to NaN
for i in range(0, nrows):
    for j in range(0, ncols):
        oput_dhdt[i, j] = numpy.NaN
        oput_wd[i, j] = numpy.NaN
        oput_phi[i, j] = numpy.NaN
        oput_gamma[i, j] = numpy.NaN
        oput_b_up[i, j] = numpy.NaN
        oput_b_down[i, j] = numpy.NaN
       
# Change the wind azimuth to the migration azimuth
mig_az = wind_az - 180.0
if mig_az < 0.0:
    mig_az = mig_az + 360.0

# Check to make sure the output directory exists, otherwise create it
if not os.path.isdir (oput_directory):
    os.mkdir (oput_directory)
    
# Set up some counters to report values at the end of the calculations
ctr_mask = 0
ctr_phi = 0
ctr_ht = 0
ctr_asp = 0
 
# ======================================================================================
# Calculate slope, aspect
statusprint ("======================================")
statusprint ("CALCULATING SLOPE AND ASPECT >>>>")

# Calculate slope and aspect with the above-defined function
slp, asp = slope_aspect (topo, cellsize)

# ======================================================================================
# Run over the mask and tag cells that meet our conditions
statusprint ("======================================")
statusprint ("ISOLATING SLIPFACE CELLS >>>>")

for i in range(0, nrows):
    for j in range(0, ncols):
        # Tag cells with the following conditions
        # 1) slope within designated ranges
        # 2) no cells on the edge of the raster
        # 3) aspect, slope, topography, and range must all have values
        # 4) aspect must have values for 8 nearest neighbors (required for interpolation)
        if slp[i, j] > minslope and slp[i, j] < maxslope:
            if i != 0 and i != (nrows - 1) and j != 0 and j != (ncols - 1):
                if not numpy.isnan(asp[i, j]) and not numpy.isnan(slp[i, j]) and not numpy.isnan(topo[i, j]):
                    if not numpy.isnan(asp[i-1, j-1]) and not numpy.isnan(asp[i-1, j]) and not numpy.isnan(asp[i-1, j+1]):
                        if not numpy.isnan(asp[i, j-1]) and not numpy.isnan(asp[i, j+1]):
                            if not numpy.isnan(asp[i+1, j-1]) and not numpy.isnan(asp[i+1, j]) and not numpy.isnan(asp[i+1, j+1]):
                                mask[i, j] = True           # if all of the conditions above are true, tag the cell
                                ctr_mask = ctr_mask + 1     # advance the mask counter
                                
# ======================================================================================
# Preparation is complete, lets start the main calculations
statusprint ("======================================")
statusprint ("PERFORMING MAIN CALCULATIONS >>>>")

# BEGIN MAIN LOOP OVER RASTER
for i in range(0, nrows):
    for j in range(0, ncols):
        # Check to see if the raster cell is pre-tagged in the mask
        if mask[i, j]:

            # Re-arrange the migration azimuth
            phi = asp[i, j] - mig_az

            # Correct phi if it is negative
            if phi < 0.0:
                phi = 360.0 + phi

            # Only continue calculation if phi is downwind
            if phi < 90.0 or phi > 270.0:
                
                ctr_phi = ctr_phi + 1   # advance correct phi counter
                
                # Convert azimuths that range from 270 to 360 to be 90 to 0
                if phi > 270.0:
                    phi = 360.0 - phi

                # Now, convert azimuths to range from 0 to 90 where 90 is
                # perpendicular to wind direction, this requires subtraction from 90 degrees
                phi = 90.0 - phi
                
                # Try to extract slipface height from 'walking' algorithm
                max_ht = walkuphill (i, j)
                min_ht = walkdownhill (i, j)
                
                # Check to make ensure we have proper measurements of the slipface height
                if not numpy.isnan (max_ht) and not numpy.isnan (min_ht):
                    
                    ctr_ht = ctr_ht + 1     # advance counter for cells with correct height
                    
                    # If we have proper measurements, continue and calculate the slipface height as difference
                    slipface_ht = max_ht - min_ht
                    
                    # Now, use the angle of repose to calculate the planimetric width of the slipface down-aspect
                    slipface_wd = slipface_ht / math.tan (repose * math.pi / 180.0)
                    
                    # Determine aspect measurements
                    asp1 = interp_aspect (i, j, 0.5 * trap_width)              # record one interpolated aspect
                    asp2 = interp_aspect (i, j, -0.5 * trap_width)             # record a second interpolated aspect
                    
                    # Check to ensure the aspect interpolation returned non-missing values before continuing
                    if not numpy.isnan (asp1) and not numpy.isnan (asp2):

                        ctr_asp = ctr_asp + 1       # advance correct aspect counter
                        
                        # Calculate the aspect differences: values will be negative if concave, and positive if convex
                        # Note that we have to be careful with subtraction if the aspects are close to due north
                        if asp1 > 270.0 and asp2 < 90.0:
                            asp_diff = (asp1 - 360.0) - asp2
                        elif asp1 < 90.0 and asp2 > 270.0:
                            asp_diff = asp1 + 360.0 - asp2
                        else:
                            asp_diff = asp1 - asp2
                        
                        # Divide the aspect difference by 2 to get 'gamma' as in the text
                        gamma = asp_diff / 2.0
                        
                        # Now determine the distance to the top and bottom of the slipface
                        dist_up = slipface_wd * (max_ht - topo[i, j]) / slipface_ht
                        dist_down = slipface_wd - dist_up
                        
                        # We can then calculate the upper and lower widths of the trapezoid
                        b_up = trap_width - (2.0 * dist_up * math.tan (gamma * math.pi / 180.0))
                        b_down = trap_width + (2.0 * dist_down * math.tan (gamma * math.pi / 180.0))
                        
                        # Check to ensure that both b_up and b_down are greater than zero
                        # If this is the case, this means that our aspect calculations are influenced by error
                        if b_up > 0.0 and b_down > 0.0:

                            # If the cell passed this check, continue with calculations and calculate the deposition rate
                            dh_dt = (flux * b_up * math.sin (phi * math.pi / 180.0)) / (slipface_wd * (b_up + b_down) / 2.0)
                            
                            # Write out the results to the output arrays
                            oput_dhdt[i, j] = dh_dt
                            oput_b_up[i, j] = b_up
                            oput_b_down[i, j] = b_down
                            oput_wd[i, j] = slipface_wd
                            oput_phi[i, j] = phi
                            oput_gamma[i, j] = gamma
                            
# ======================================================================================
# Output a csv file of the results, in csv table format (comma delimited ascii text file)
statusprint ("======================================")
statusprint ("WRITING OUTPUT TEXT FILE >>>>")
oput_fname = os.path.join (oput_directory, 'results_table.csv')
f_oput = file (oput_fname,  mode = 'w')
   
# Write the header
f_oput.write ("ID,row,col,slp_wd,phi,dhdt,slope,aspect,gamma,b_up,b_down,elev\n")

# Loop through all the columns and rows in dhdt and write out the data to a local csv file
val_counter = 1
for i in range (0, asp.shape[0]):
    for j in range (0, asp.shape[1]):
        # If the output is not missing, write it to the file, each on its own line
        if not numpy.isnan(oput_dhdt[i, j]):
            f_oput.write (str(val_counter) + ",")       # write ID
            f_oput.write (str(i) + ",")                 # write row
            f_oput.write (str(j) + ",")                 # write column
            f_oput.write (str(oput_wd[i, j]) + ",")     # write slipface width
            f_oput.write (str(oput_phi[i, j]) + ",")    # write phi
            f_oput.write (str(oput_dhdt[i, j]) + ",")   # write gamma
            f_oput.write (str(slp[i, j]) + ",")         # write slope
            f_oput.write (str(asp[i, j]) + ",")         # write aspect
            f_oput.write (str(oput_gamma[i, j]) + ",")  # write aspect divergence
            f_oput.write (str(oput_b_up[i, j]) + ",")   # write b_up
            f_oput.write (str(oput_b_down[i, j]) + ",") # write b_down
            f_oput.write (str(topo[i, j]) + "\n")       # write elevation and endline char
            val_counter = val_counter + 1

f_oput.close()

# ======================================================================================  
# Output a raster file of the deposition rate results
# Prepare file names for saving
statusprint ("======================================")
statusprint ("WRITING OUTPUT RASTER FILE (S) >>>>")
write_raster (oput_dhdt, 'dhdt')
    
# If we are operating in diagnostics mode, output everything else as rasters as well
if diagnostics:
    write_raster (slp, 'slope')
    write_raster (asp, 'aspect')
    write_raster (oput_wd, 'slip_wd')
    write_raster (oput_phi, 'phi')
    write_raster (oput_gamma, 'gamma')
    write_raster (oput_b_up, 'b_up')
    write_raster (oput_b_down, 'b_down')
        
    
# ======================================================================================
# Print closing messages
statusprint ("======================================")
statusprint ("SCRIPT FINISHED >>>>")
statusprint ("Time: " + str(datetime.datetime.now()))
statusprint ("Successfully measured slipface angle for " + str(val_counter - 1) + " cells")

if diagnostics:
    statusprint ("1) Masked cells: " + str(ctr_mask))
    statusprint ("2) Correct phi cells: " + str(ctr_phi))
    statusprint ("3) Correct height cells: " + str(ctr_ht))
    statusprint ("4) Correct aspect cells: " + str(ctr_asp))
    statusprint ("5) Final calc cells: " + str(val_counter - 1))
    

time.sleep(3)       # sleep for a short moment to view results before the console disappears



